#pragma config(Sensor, S1,     lichtsensor,    sensorLightActive)
#pragma config(Sensor, S2,     zonar,          sensorSONAR)
#pragma config(Sensor, S4,     kleursensor,    sensorColorNxtFULL)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define snelheid 25

int PowerA;
int PowerB;
int Tp = 0; //variabele voor basissnelheid
int basistoestand = 0;
int stuurwaarde = 0;

task accelerate();
task deaccelerate();
task linetracking();
task kruispuntdetectie();

void calibrate ()
{
	int sensor;
	int min = 100;
	int max = 0;
	motor[motorA] = 20;
	motor[motorB] = -20;
	for (int i = 0; i < 600; i++)
	{
		sensor = SensorValue(lichtsensor);
		if (sensor <= min)
		{
			min = sensor;
		}
		else if (sensor >= max)
		{
			max = sensor;
		}
		if (i == 99)
		{
			motor[motorA] = -20;
			motor[motorB] = 20;
		}
		if (i == 299)
		{
			motor[motorA] = 20;
			motor[motorB] = -20;
		}
		if (i == 499)
		{
			motor[motorA] = -20;
			motor[motorB] = 20;
		}
		wait1Msec(10);
	}
	basistoestand = (max + min)/2;
}

task linetracking ()
{
	int Kp = 3;
	int Ki = 0.4;
	int Kd = 0;
	int integraal = 0;
	int vorige_error = 0;
	while (true)
	{
		while (SensorValue(zonar) > 10)
		{
				int LightValue = SensorValue(lichtsensor);
				stuurwaarde = basistoestand;
				int error = LightValue - stuurwaarde; // afstand van basistoestand
				int afgeleide = error - vorige_error; //afgeleide kijkt naar het verschil tussen twee opeenvolgende errors om zo te voorspellen wat de volgende error zal zijn
				integraal = integraal + error; //de integraal onthoud de som van variabele error, om de afwijking uit het verleden te corrigeren
				int Turn = (Kp * error) + (Ki*integraal) + (Kd * afgeleide); //berekent hoe sterk de motorwaarde veranderd
				PowerA = Tp - Turn; //verandering van motorwaardeA ten opzichte van basissnelheid
				PowerB = Tp + Turn; //verandering van motorwaardeB ten opzichte van basissnelheid
				motor[motorA] = PowerA;
				motor[motorB] = PowerB;
				vorige_error = error;
				if (motor[motorA] != 0)
					nVolume = 4;// de motor staat aan dus geluid moet aan
				else
					nVolume = 0;
		}
		motor[motorA] = 0;
		motor[motorB] = 0;
		nVolume = 0;
	}
}

task rechtdoor ()
{
	while (SensorValue(kleursensor) == BLACKCOLOR)
	{
		motor[motorA] = snelheid;
		motor[motorB] = snelheid;
	}
	startTask(linetracking);
}

task linksaf ()
{
	stopTask(kruispuntdetectie);
	motor[motorA] = 15;
	motor[motorB] = 15;
	for (int i = 0; i <= 30; i++)
	{
		motor[motorA] = motor[motorA] - 1;
		motor[motorB] = motor[motorB] + 1;
		wait1Msec(60);
	}
	startTask(linetracking);
	startTask(kruispuntdetectie);
}

task rechtsaf ()
{
	stopTask(kruispuntdetectie);
	motor[motorA] = 15;
	motor[motorB] = 15;
	for (int i = 0; i <= 30; i++)
	{
		motor[motorB] = motor[motorB] - 1;
		motor[motorA] = motor[motorA] + 1;
		wait1Msec(60);
	}
	wait1Msec(500);
	startTask(linetracking);
	startTask(kruispuntdetectie);
}

task kruispuntdetectie()
{
	while(1)
	{

	if (SensorValue(kleursensor) == BLACKCOLOR)
	{
		stopTask(linetracking);
		startTask(rechtsaf);
	}
}
}

task accelerate() // hoogt geleidelijk de basissnelheid op
{
	stopTask(deaccelerate);
	int j = Tp;
	for (int i = j; i <= snelheid; i++)
	{
		wait10Msec(8);
		Tp = i;
	}
	stopTask(accelerate);
}

task deaccelerate()
{
	stopTask(accelerate);
	int j = Tp;
	for (int i = j; i >= 0; i--)
	{
		wait1Msec(80);
		Tp = i;
		if (SensorValue(zonar) <= 10)
			break;
	}
	Tp = 0;
	stopTask(deaccelerate);
}


task geluid() // produceert geluid
{
	while(1)
	{
			playSoundFile("paardg.rso");
	}
}

task main()
{
	calibrate();
	startTask(geluid);
	startTask(accelerate);
	startTask(kruispuntdetectie);
	startTask(linetracking);
	while (1)
		{
			wait10Msec(1);
		}
}
