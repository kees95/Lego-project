#pragma config(Sensor, S1,     lichtsensor,    sensorLightActive)
#pragma config(Sensor, S2,     zonar,          sensorSONAR)
#pragma config(Sensor, S4,     kleursensor,    sensorColorNxtFULL)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define snelheid 30

int PowerA;
int PowerB;
int Tp = 0; //variabele voor basissnelheid
int basistoestand;

void calibrate ()
{
	int sensor;
	int min = 100;
	int max = 0;
	motor[motorA] = 10;
	motor[motorB] = -10;
	for (int i = 0; i < 600; i++)
	{
		sensor = SensorValue(lichtsensor);
		if (sensor <= min)
		{
			min = sensor;
		}
		else if (sensor >= max)
		{
			max = sensor;
		}
		if (i == 99)
		{
			motor[motorA] = -10;
			motor[motorB] = 10;
		}
		if (i == 299)
		{
			motor[motorA] = 10;
			motor[motorB] = -10;
		}
		if (i == 499)
		{
			motor[motorA] = -10;
			motor[motorB] = 10;
		}
		wait1Msec(10);
	}
	basistoestand = (max + min)/2;
}

task accelerate() // hoogt geleidelijk de basissnelheid op
{
	int j = Tp;
	for (int i = j; i <= snelheid; i++)
	{
		wait10Msec(8);
		Tp = i;
	}
}

task geluid() // produceert geluid
{
	while(1)
	{
		if (PowerA != 0 && PowerB != 0)
		{
			playSoundFile("paardg.rso");
			nVolume = 4;
		}
	}
}

task main()
{
	calibrate();
	startTask(geluid);
	startTask(accelerate);
	int Kp = 7; // proportionele constante
	int Ki = 0.7;
	int Kd = 70;
	int integraal = 0;
	int vorige_error = 0;
	while (true)
	{
		while (SensorValue(zonar) > 10) // als de robot binnen 10(cm?) niks detecteert, initialiseert deze iteratie
		{
				nVolume = 4;// de motor staat aan dus geluid moet aan
				int LightValue = SensorValue(lichtsensor);
				int error = LightValue - basistoestand; // afstand van basistoestand
				int afgeleide = error - vorige_error; //afgeleide kijkt naar het verschil tussen twee opeenvolgende errors om zo te voorspellen wat de volgende error zal zijn
				integraal = integraal + error; //de integraal onthoud de som van variabele error, om de afwijking uit het verleden te corrigeren
				int Turn = (Kp * error) + (Ki*integraal) + (Kd * afgeleide); //berekent hoe sterk de motorwaarde veranderd
				PowerA = Tp - Turn; //verandering van motorwaardeA ten opzichte van basissnelheid
				PowerB = Tp + Turn; //verandering van motorwaardeB ten opzichte van basissnelheid
				motor[motorA] = PowerA;
				motor[motorB] = PowerB;
				vorige_error = error;
				wait1Msec(5);
		}
		motor[motorA] = 0;
		motor[motorB] = 0;
		nVolume = 0;// de motor staat uit dus geluid moet uit
	}
}
