#pragma config(Sensor, S1,     lichtsensor,    sensorLightActive)
#pragma config(Sensor, S2,     zonar,          sensorSONAR)
#pragma config(Sensor, S4,     kleursensor,    sensorColorNxtFULL)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#pragma platform(NXT)

const int kMaxSizeOfMessage = 30;
const int INBOX = 5;

#define snelheid 30

int PowerA;
int PowerB;
int Tp = 0; //variabele voor basissnelheid
int basistoestand;

void calibrate ()
{
	int sensor;
	int min = 100;
	int max = 0;
	motor[motorA] = 10;
	motor[motorB] = -10;
	for (int i = 0; i < 600; i++)
	{
		sensor = SensorValue(lichtsensor);
		if (sensor <= min)
		{
			min = sensor;
		}
		else if (sensor >= max)
		{
			max = sensor;
		}
		if (i == 99)
		{
			motor[motorA] = -10;
			motor[motorB] = 10;
		}
		if (i == 299)
		{
			motor[motorA] = 10;
			motor[motorB] = -10;
		}
		if (i == 499)
		{
			motor[motorA] = -10;
			motor[motorB] = 10;
		}
		wait1Msec(10);
	}
	basistoestand = (max + min)/2;
}


task accelerate() // hoogt geleidelijk de basissnelheid op
{
	int j = Tp;
	for (int i = j; i <= snelheid; i++)
	{
		wait10Msec(8);
		Tp = i;
	}
	stopTask(accelerate);
}

task geluid() // produceert geluid
{
	while(1)
	{
			playSoundFile("paardg.rso");
	}
}

int bluetooth()
{
  TFileIOResult nBTCmdRdErrorStatus;
  int nSizeOfMessage;
  ubyte nRcvBuffer[kMaxSizeOfMessage];

	while (true)
  {
    // Check to see if a message is available
    nSizeOfMessage = cCmdMessageGetSize(INBOX);

    if (nSizeOfMessage > kMaxSizeOfMessage)
      nSizeOfMessage = kMaxSizeOfMessage;
    if (nSizeOfMessage > 0){
    	nBTCmdRdErrorStatus = cCmdMessageRead(nRcvBuffer, nSizeOfMessage, INBOX);
    	nRcvBuffer[nSizeOfMessage] = '\0';
    	string s = "";
    	stringFromChars(s, (char *) nRcvBuffer);
    	if(s == "UP"){
    			return 1;
    	}
     if(s == "DOWN"){
    			return 2;
    	}
    	if(s == "LEFT"){
    			return 3;
    	}
    	if(s == "RIGHT"){
    			return 4;
    	}
    	if(s == "A"){
    			return 5;
    	}
    	if(s == "B"){
    			return 6;
    	}
    	if(s == "C"){
    			return 7;
    	}
    }
    wait1Msec(100);
  }
  //Als er niets gebeurt 0 retourneren.
  //return 0;
}

task kruispunt()
{

		if (bluetooth() == 1) // rechtdoor
		{
			motor[motorA] = 10;
    	motor[motorB] = 10;
    	wait1Msec(2000);
    	stopTask(kruispunt);
		}
		else if (bluetooth() == 3) //links afslaan
		{
			motor[motorA] = 20;
    	motor[motorB] = 5;
    	wait1Msec(2000);
    	stopTask(kruispunt);
		}
		else if (bluetooth() == 4) // rechts afslaan
		{
			motor[motorA] = 5;
    	motor[motorB] = 20;
    	wait1Msec(2000);
    	stopTask(kruispunt);
		}

}

task kruispuntdetectie()
{
	while(1)
	{

	if (SensorValue(kleursensor) == BLACKCOLOR)
	{
		//Tp = 0;
		startTask(kruispunt);
	}
}
}


task main()
{
	calibrate();
	startTask(geluid);
	startTask(accelerate);
	int Kp = 7; // proportionele constante
	int Ki = 0.7;
	int Kd = 70;
	int integraal = 0;
	int vorige_error = 0;
	startTask(kruispuntdetectie);

	while (true)
	{
		while (SensorValue(zonar) > 20)
		{
				nVolume = 4;// de motor staat aan dus geluid moet aan
				int LightValue = SensorValue(lichtsensor);
				int error = LightValue - basistoestand; // afstand van basistoestand
				int afgeleide = error - vorige_error; //afgeleide kijkt naar het verschil tussen twee opeenvolgende errors om zo te voorspellen wat de volgende error zal zijn
				integraal = integraal + error; //de integraal onthoud de som van variabele error, om de afwijking uit het verleden te corrigeren
				int Turn = (Kp * error) + (Ki*integraal) + (Kd * afgeleide); //berekent hoe sterk de motorwaarde veranderd
				PowerA = Tp - Turn; //verandering van motorwaardeA ten opzichte van basissnelheid
				PowerB = Tp + Turn; //verandering van motorwaardeB ten opzichte van basissnelheid
				motor[motorA] = PowerA;
				motor[motorB] = PowerB;
				vorige_error = error;
				wait1Msec(5);
				nVolume = 4;// de motor staat aan dus geluid moet aan
		}

		motor[motorA] = 0;
		motor[motorB] = 0;
		nVolume = 0;// de motor staat uit dus geluid moet uit
		wait1Msec(1);
	}
}
